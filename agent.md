è¿™æ˜¯ä¸€ä»½ä¸ºäº†æ‰“é€ **â€œä¼ ä¸–ä¹‹ä½œâ€ (Heirloom Quality)** çº§åˆ«çš„ C++ æ•™å­¦æ‰§è¡Œå™¨è€Œåˆ¶å®šçš„å…¨æ–¹ä½å·¥ä½œæŒ‡å—ã€‚

è¿™ä»½æ–‡æ¡£å°†ä½œä¸ºæˆ‘ä»¬æ„å»º **Eternity Kernel (æ°¸æ’å†…æ ¸)** çš„ç»å¯¹çº²é¢†ã€‚

---

# ğŸ› ï¸ Eternity Kernel é¡¹ç›®å·¥ä½œæŒ‡å—

## 1. æ ¸å¿ƒç›®æ ‡ (Core Objective)

æ„å»ºä¸€ä¸ªåŸºäº **Web çš„ã€å¯è§†åŒ–çš„ã€åŸå­çº§çš„** C++ ç®€æ˜“è§£é‡Šå™¨å†…æ ¸ã€‚

*   **æè‡´åŸå­åŒ–**: æ‰“ç ´â€œä¸€è¡Œä»£ç ä¸€æ­¥â€çš„é™åˆ¶ï¼Œå®ç°â€œè¡¨è¾¾å¼çº§â€çš„å¯è§†åŒ–ï¼ˆå¦‚ `sum += arr[i]` æ‹†è§£ä¸º å–å€->å–å€¼->ç´¯åŠ ->å›å†™ï¼‰ã€‚
*   **æ·±åº¦å†…å­˜æ¨¡å‹**: ä¸¥è°¨æ¨¡æ‹Ÿ **æ ˆ (Stack)** ä¸ **å † (Heap)** çš„åˆ†ç¦»ï¼ŒçœŸå®è¿˜åŸå˜é‡ç”Ÿå‘½å‘¨æœŸå’Œå†…å­˜å¼•ç”¨å…³ç³»ã€‚
*   **æ™ºèƒ½å®ˆå« (Guardian)**: æä¾›å¸¦æœ‰ä¸Šä¸‹æ–‡çš„ä¸­æ–‡å‹å¥½æŠ¥é”™ï¼ˆå¦‚ï¼šè¶Šç•Œæ£€æŸ¥ã€æ­»å¾ªç¯é¢„è­¦ã€æœªåˆå§‹åŒ–å˜é‡æ‹¦æˆªï¼‰ã€‚
*   **åå¹´æ¶æ„**: é‡‡ç”¨ **Compiler + VM (è™šæ‹Ÿæœº)** æ¶æ„ï¼Œç¡®ä¿æ ¸å¿ƒæŒ‡ä»¤é›† (ISA) ç¨³å®šï¼Œä¸Šå±‚è¯­æ³•å¯éšæ„æ‰©å±•ã€‚

---

## 2. å®è§‚æ¶æ„è®¾è®¡ (Architecture Blueprint)

ç³»ç»Ÿé‡‡ç”¨å…¸å‹çš„ **ä¸‰å±‚æ¶æ„**ï¼š

1.  **Compiler Layer (ç¼–è¯‘å™¨å±‚)**: è´Ÿè´£ç†è§£ä»£ç ã€‚
    *   `Source` -> `Lexer` -> `Tokens` -> `Parser` -> `AST` -> `CodeGen` -> `Bytecode`
2.  **Core Layer (å†…æ ¸å±‚/VM)**: è´Ÿè´£æ‰§è¡Œä¸çŠ¶æ€ç®¡ç†ï¼ˆé»‘ç›’å­ï¼‰ã€‚
    *   æ‰§è¡Œç¼–è¯‘åçš„ `OpCode` æŒ‡ä»¤æµã€‚
    *   ç»´æŠ¤ `CallStack` (æ ˆå¸§) å’Œ `Heap` (å †å†…å­˜)ã€‚
    *   é€šè¿‡ `Guardian` è¿›è¡Œå®æ—¶å®‰å…¨æ‹¦æˆªã€‚
3.  **Trace Layer (è¿½è¸ªå±‚)**: è´Ÿè´£ç”Ÿæˆå¯è§†åŒ–æ•°æ®ã€‚
    *   VM æ¯æ‰§è¡Œä¸€æ­¥ï¼Œç”Ÿæˆä¸€ä¸ªåŸå­ `Event`ã€‚
    *   å‰ç«¯â€œæ’­æ”¾å™¨â€æ¶ˆè´¹è¿™äº› Event è¿›è¡Œæ¸²æŸ“ã€‚

---

## 3. Phase 1: åœ°åŸºåŠŸèƒ½è§„èŒƒ (Foundation Specs)

æœ¬é˜¶æ®µä¸æ¶‰åŠå¤æ‚çš„æ•°æ®ç»“æ„ï¼ˆå¦‚ STLï¼‰ï¼Œä¸“æ³¨äºæ„å»ºå›¾çµå®Œå¤‡çš„è®¡ç®—ä¸æµç¨‹æ§åˆ¶èƒ½åŠ›ã€‚

### 3.1 å˜é‡ä¸æ•°æ®ç±»å‹
*   **æ”¯æŒç±»å‹**:
    *   `int`: æ ¸å¿ƒæ•™å­¦ç±»å‹ã€‚**æ³¨æ„**: å¿…é¡»æ¨¡æ‹Ÿ C++ çš„æ•´æ•°é™¤æ³•æˆªæ–­è¡Œä¸º (e.g., `5/2 = 2`)ã€‚
    *   `double`: æµ®ç‚¹æ•°è¿ç®—ã€‚
    *   `bool`: çœŸå‡å€¼ (ç”¨äºæ¡ä»¶åˆ¤æ–­)ã€‚
*   **ä½œç”¨åŸŸ (Scope)**:
    *   å®ç°**å—çº§ä½œç”¨åŸŸ** (`{ ... }`)ã€‚
    *   å®ç°**å˜é‡é®è”½ (Shadowing)**: å†…å±‚ `{ int a; }` é®ç›–å¤–å±‚ `int a;`ï¼Œä¸”å†…å±‚é”€æ¯åå¤–å±‚æ¢å¤è®¿é—®ã€‚

### 3.2 è¿ç®—ç¬¦ (Operators)
*   **ç®—æœ¯**: `+`, `-`, `*`, `/` (åŒºåˆ†æ•´æ•°/æµ®ç‚¹), `%`ã€‚
*   **èµ‹å€¼**: `=`, `+=`, `-=`, `*=`, `/=`, `%=`ã€‚
*   **è‡ªå¢å‡**: `i++`, `++i`ã€‚
    *   *åŸå­åŒ–è¦æ±‚*: `i++` éœ€æ‹†è§£ä¸º `LOAD i` -> `COPY` -> `INC` -> `STORE i` -> `RETURN COPY`ã€‚
*   **æ¯”è¾ƒ**: `==`, `!=`, `>`, `<`, `>=`, `<=`ã€‚
*   **é€»è¾‘**: `&&`, `||`, `!` (å¿…é¡»æ”¯æŒçŸ­è·¯æ±‚å€¼ï¼šå¦‚æœ `&&` å·¦ä¾§ä¸ºå‡ï¼Œä¸æ‰§è¡Œå³ä¾§æŒ‡ä»¤)ã€‚

### 3.3 ä¸‰å¤§æ§åˆ¶ç»“æ„
*   **é¡ºåºç»“æ„**: æŒ‡ä»¤æŒ‡é’ˆ (IP) è‡ªåŠ¨è‡ªå¢ã€‚
*   **é€‰æ‹©ç»“æ„**: `if`, `else`ã€‚
    *   *å®ç°*: ä½¿ç”¨ `JUMP_IF_FALSE` æŒ‡ä»¤è·³è¿‡ä»£ç å—ã€‚
*   **å¾ªç¯ç»“æ„**: `while`, `for`ã€‚
    *   *å¯è§†åŒ–é‡ç‚¹*: æ¸…æ™°å±•ç¤º `Init` -> `Check` -> `Body` -> `Update` -> `Check` çš„è·³è½¬æµç¨‹ã€‚

### 3.4 åŸç”Ÿæ•°ç»„ (Native Arrays)
*   **å®šä¹‰**: `int arr[5];` æˆ– `int arr[3] = {1, 2, 3};`
*   **å†…å­˜æ¨¡å‹**:
    *   **Stack**: å­˜å‚¨ä¸€ä¸ª `Pointer` (åŒ…å«åœ°å€ `addr` + å…ƒæ•°æ® `type: array`).
    *   **Heap**: å®é™…å­˜å‚¨è¿ç»­çš„æ•°å€¼ç©ºé—´ `[v1, v2, v3, ...]`.
*   **å®ˆå«æ£€æŸ¥**: æ¯æ¬¡è®¿é—® `arr[i]`ï¼Œå¿…é¡»æ ¡éªŒ `0 <= i < length`ã€‚

---

## 4. ç›®å½•ç»“æ„ (Directory Structure)

```text
/src
  /core                    <-- [å†…æ ¸å±‚] è™šæ‹Ÿæœºå¿ƒè„
    /isa
      opcodes.ts           // æŒ‡ä»¤æšä¸¾å®šä¹‰ (ADD, JUMP, LOAD_IDX...)
      instructions.ts      // æŒ‡ä»¤æ•°æ®æ¥å£ (å¸¦ SourceMap)
    /memory
      stack.ts             // CallStack & StackFrame å®ç°
      heap.ts              // Heap å®ç° (Array å­˜å‚¨)
      values.ts            // Value ç±»å‹å®šä¹‰ (number, boolean, Pointer)
    /vm
      virtual-machine.ts   // VM ä¸»å¾ªç¯ (Generator)
      alu.ts               // ç®—æœ¯é€»è¾‘å•å…ƒ (å¤„ç† int/double è¿ç®—è§„åˆ™)
      guardian.ts          // è¿è¡Œæ—¶é”™è¯¯æ‹¦æˆªå™¨
    /trace
      events.ts            // å¯¹å¤–æš´éœ²çš„åŸå­äº‹ä»¶å®šä¹‰ (TraceEvent)

  /lang                    <-- [ç¼–è¯‘å™¨å±‚] C++ è§£æ
    /lexer                 // åˆ†è¯å™¨
    /parser                // è¯­æ³•åˆ†æå™¨ (ç”Ÿæˆ AST)
    /codegen               // ä»£ç ç”Ÿæˆå™¨ (AST -> OpCodes)
      expression.ts        // è¡¨è¾¾å¼ç¼–è¯‘
      statement.ts         // è¯­å¥ç¼–è¯‘
    
  /shared                  <-- [å…¬å…±å·¥å…·]
    errors.ts              // ç»“æ„åŒ–é”™è¯¯å®šä¹‰ (RuntimeError, SyntaxError)
    utils.ts               // é€šç”¨å·¥å…·å‡½æ•°

  /tests                   <-- [æµ‹è¯•å·¥å‚]
    /unit                  // å•å…ƒæµ‹è¯• (æµ‹è¯• Memory, ALU)
    /integration           // é›†æˆæµ‹è¯• (C++ æºç  -> VM æ‰§è¡Œç»“æœ)
      cases_basic.ts       // åŸºç¡€è¿ç®—æµ‹è¯•
      cases_flow.ts        // å¾ªç¯è·³è½¬æµ‹è¯•
      cases_array.ts       // æ•°ç»„ä¸è¶Šç•Œæµ‹è¯•
```

---

## 5. å¼€å‘è·¯çº¿ä¸å®æ–½æ­¥éª¤ (Implementation Roadmap)

### Stage 1: è™šæ‹Ÿæœºçš„éª¨æ¶ (The Bare Metal)
**ç›®æ ‡**: ä¸å†™ä¸€è¡Œ C++ è§£æä»£ç ï¼Œæ‰‹åŠ¨æ„é€ æŒ‡ä»¤æµï¼Œè·‘é€šè™šæ‹Ÿæœºã€‚

1.  **å®šä¹‰ ISA (æŒ‡ä»¤é›†)**: ç¼–å†™ `opcodes.ts`ã€‚å®šä¹‰ `PUSH`, `POP`, `ADD`, `PRINT`ã€‚
2.  **æ„å»ºå†…å­˜**: ç¼–å†™ `stack.ts`ã€‚å®ç°å˜é‡çš„ `define`, `resolve`, `assign`ã€‚
3.  **å®ç° VM å¾ªç¯**: ç¼–å†™ `virtual-machine.ts`ã€‚å®ç° `Fetch` -> `Execute` å¾ªç¯ï¼Œå¤„ç†åŸºç¡€ç®—æœ¯æŒ‡ä»¤ã€‚
4.  **æµ‹è¯•**: æ‰‹å†™æ±‡ç¼– `PUSH 1, PUSH 2, ADD, PRINT`ï¼ŒéªŒè¯è¾“å‡º 3ã€‚

### Stage 2: æµç¨‹æ§åˆ¶ä¸å¤æ‚å†…å­˜ (Flow & Memory)
**ç›®æ ‡**: å®ç°å¾ªç¯è·³è½¬å’Œå †å†…å­˜æ•°ç»„ã€‚

1.  **æ‰©å±• ISA**: å¢åŠ  `JUMP`, `JUMP_IF_FALSE`, `ALLOC_ARR`, `LOAD_IDX`, `STORE_IDX`ã€‚
2.  **æ„å»º Heap**: ç¼–å†™ `heap.ts`ï¼Œæ¨¡æ‹Ÿå†…å­˜åˆ†é…ã€‚
3.  **å®ç° Guardian**: åœ¨ `LOAD_IDX` ä¸­åŠ å…¥è¶Šç•Œæ£€æŸ¥é€»è¾‘ï¼ŒæŠ›å‡ºç»“æ„åŒ–é”™è¯¯ã€‚
4.  **æµ‹è¯•**: æ‰‹å†™æ±‡ç¼–æ¨¡æ‹Ÿ `for` å¾ªç¯éå†æ•°ç»„ï¼ŒéªŒè¯ `i` è¶Šç•Œæ—¶æ˜¯å¦æŠ¥é”™ã€‚

### Stage 3: ç¼–è¯‘å™¨å‰ç«¯ (The Compiler)
**ç›®æ ‡**: è®©æœºå™¨èƒ½è¯»æ‡‚ C++ å­—ç¬¦ä¸²ã€‚

1.  **Lexer/Parser**: ä½¿ç”¨ç°æœ‰å·¥å…· (å¦‚ Acorn ä¿®æ”¹ç‰ˆæˆ–ç®€æ˜“æ‰‹å†™ Parser) å°† C++ æºç è½¬ä¸º ASTã€‚
2.  **CodeGen**:
    *   å®ç° `ExprCompiler`: å°† `1 + 2 * 3` è½¬ä¸ºååºæŒ‡ä»¤æµã€‚
    *   å®ç° `StmtCompiler`: å°† `if/for` è½¬ä¸ºå¸¦ `JUMP` çš„æŒ‡ä»¤æµã€‚
3.  **é›†æˆ**: ä¸²è” `Source -> Compiler -> VM`ã€‚

---

## 6. æµ‹è¯•ä¸éªŒæ”¶è§„åˆ™ (Testing Rules)

ä¸ºäº†ä¿è¯â€œä¼ ä¸–ä¹‹ä½œâ€çš„ç¨³å®šæ€§ï¼Œå¿…é¡»éµå®ˆä»¥ä¸‹æµ‹è¯•æ ‡å‡†ï¼š

1.  **é»‘ç›’å¿«ç…§æµ‹è¯• (Snapshot Testing)**:
    *   ä¸ä»…ä»…æµ‹è¯•æœ€ç»ˆç»“æœ `sum == 10`ã€‚
    *   **å¿…é¡»æµ‹è¯• Trace åºåˆ—**: è®°å½• VM äº§ç”Ÿçš„æ¯ä¸€ä¸ª Event åºåˆ—ã€‚å¦‚æœé‡æ„ä»£ç åï¼Œ`i++` çš„ Event é¡ºåºå˜äº†ï¼Œæµ‹è¯•å¿…é¡»æŠ¥é”™ã€‚è¿™ä¿è¯äº†å¯è§†åŒ–æ•ˆæœçš„ç¨³å®šæ€§ã€‚
2.  **è¾¹ç•Œæ¡ä»¶åœ°ç‹± (Corner Case Hell)**:
    *   é™¤ä»¥é›¶ (`1 / 0`)ã€‚
    *   æ•°ç»„è¶Šç•Œ (`arr[-1]`, `arr[length]`)ã€‚
    *   æœªåˆå§‹åŒ–å˜é‡çš„ä½¿ç”¨ (`int a; cout << a;`)ã€‚
    *   ç©ºå¾ªç¯ (`while(false) {}`)ã€‚
3.  **æ•´æ•°è¿ç®—ä¸€è‡´æ€§**:
    *   è¾“å…¥ `7 / 2`ï¼Œå¿…é¡»æ–­è¨€ç»“æœæ˜¯ `3` (int)ï¼Œè€Œä¸æ˜¯ `3.5` (double)ã€‚


## 7. è§„åˆ™
ä»£ç æ˜¯é¢å‘ä¸­æ–‡æ¯è¯­çš„  å§‹ç»ˆä»¥ä¸­æ–‡å›ç­”, å¹¶ä¸”ä¸­æ–‡æ³¨é‡Š

